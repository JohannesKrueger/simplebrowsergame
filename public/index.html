<html> <!-- Set Game Name and Icon -->
     <title>Simple Browser Game</title>
    <link rel="shortcut icon" type="image/x-icon" href="assets/img/favicon.ico"/>
<head>

<style>  <!-- Build Start-Menu Background -->
   
    html, body {
        padding: 0;
        margin: 0;
    }

    canvas {
        background-image: url('assets/img/background_menu.jpg');
        background-size: cover;
        width: 100%;
        height: 100%;
        border: 1px solid black;
    }

</style>

</head>
<body>

<canvas></canvas>

<script src="/socket.io/socket.io.js"></script>
<script>

const socket = io()

const canvas = document.getElementsByTagName('canvas')[0]
canvas.width = window.innerWidth
canvas.height = window.innerHeight

const ctx = canvas.getContext('2d')


const MARIO_WIDTH = 32;
const MARIO_HEIGHT = 39;
const mario = new Image();
mario.src = 'assets/img/bg.png';
mario.onload = () => {
ctx.drawImage(
    // Image
    mario,
    // ---- Selection ----
    0, // sx
    MARIO_HEIGHT * 2, // sy
    MARIO_WIDTH, // sWidth
    MARIO_HEIGHT, // sHeight
    // ---- Drawing ----
    0, // dx
    0, // dy
    MARIO_WIDTH, // dWidth
    MARIO_HEIGHT // dHeight
  );
};


// ctx.fillRect(50, 50, 100, 100)

const keyboardState = {}

function renderAvatar (player) {
    if (player.eliminated) return

    ctx.save()
    ctx.translate(player.x, player.y)

    // draw body
    ctx.beginPath()
    ctx.arc(0, 0, 20, 0, 2 * Math.PI)
    ctx.closePath()
    ctx.fillStyle = player.color
    ctx.fill()

    // draw username
    ctx.textAlign = 'center'
    ctx.fillStyle = 'black'
    ctx.font = '30px serif';
    ctx.fillText(player.username, 0, -40)

    // draw eyes
    // rotate here prior to drawing the eyes,
    // to make the eyes face that the avatar should have
    switch (player.rotation) {
        case FACING_DOWN: 
            ctx.rotate(0)
            break
        case FACING_UP:
            ctx.rotate(Math.PI)
            break
        case FACING_LEFT:
            ctx.rotate(Math.PI / 2)
            break
        case FACING_RIGHT:
            ctx.rotate(Math.PI * 1.5)
            break
    }
    // projectile gun
    ctx.beginPath()
    ctx.moveTo(-5, 5)
    ctx.lineTo(-5, 27)
    ctx.moveTo(5, 5)
    ctx.lineTo(5, 27)
    ctx.lineWidth = 10
    ctx.strokeStyle = '#5f6369';
    ctx.stroke()

    ctx.restore()
}

function renderProjectile (projectile, player) {
    if (player.eliminated) return
    
    ctx.save()
    ctx.translate(projectile.x, projectile.y)

    ctx.beginPath()
    ctx.arc(0, 0, 8, 0, 2 * Math.PI)
    ctx.closePath()
    ctx.fillStyle = '#0c0c0c'
    ctx.fill()

    ctx.restore()
}

const PROJECTILE_SPEED = 7
const PLAYER_SPEED = 3
const FACING_UP = 2
const FACING_DOWN = 0
const FACING_LEFT = 1
const FACING_RIGHT = 3

const gameState = {
    players: [
        {   
            username: prompt("Bitte gib deinen Benutzernamen ein."),
            playerId: Math.floor(Math.random() * 1000),
            x: Math.floor(Math.random() * (screen.width - 150 )), y: Math.floor(Math.random() * (screen.height - 150)),
            color: '#0080ff',
            rotation: FACING_DOWN,
            projectiles: []
        }
    ]
}

const myPlayerId = gameState.players[0].playerId

function render (state) {
    ctx.fillStyle = 'white'
    ctx.fillRect(0, 0, canvas.width, canvas.height)

    state.players.forEach(function (player) {
        renderAvatar(player)

        player.projectiles.forEach(function (projectile) {
            renderProjectile(projectile, player)
        })
    })

}

const PLAYER_RADIUS = 20
const PROJECTILE_RADIUS = 8

function hitTestPlayerVsPlayer (playerA, playerB) {
    return Math.sqrt(Math.pow(playerA.x - playerB.x, 2) + Math.pow(playerA.y - playerB.y, 2)) < (PLAYER_RADIUS * 2)
}
function hitTestPlayerVsProjectile (player, projectile) {
    return Math.sqrt(Math.pow(player.x - projectile.x, 2) + Math.pow(player.y - projectile.y, 2)) < (PLAYER_RADIUS + PROJECTILE_RADIUS)
}

function logicStep (state) {
    state.players.forEach(player => { // just another way of writing f
        player.projectiles.forEach(projectile => {
            projectile.x += projectile.vx
            projectile.y += projectile.vy

            if (projectile.x < 0 || projectile.x > window.innerWidth ||
                projectile.y < 0 || projectile.y > window.innerHeight) {
                projectile.remove = true
            }
        })
        player.projectiles = player.projectiles.filter(projectile => {
            const shouldBeKept = (projectile.remove !== true)
            return shouldBeKept
        })
    })

    // only moving player one now and setting border to screen width,-height
    const myPlayer = state.players[0]
    if (!myPlayer.eliminated) {
        if (keyboardState.w && state.players[0].y > 50) {
            myPlayer.y -= PLAYER_SPEED
            myPlayer.rotation = FACING_UP
        }
        if (keyboardState.s && state.players[0].y < screen.height - 150) {
            myPlayer.y += PLAYER_SPEED
            myPlayer.rotation = FACING_DOWN
        }
        if (keyboardState.d && state.players[0].x < screen.width - 50) {
            state.players[0].x += PLAYER_SPEED
            myPlayer.rotation = FACING_RIGHT
        }
        if (keyboardState.a && state.players[0].x > 50) {
            state.players[0].x -= PLAYER_SPEED
            myPlayer.rotation = FACING_LEFT
        }
    }

    // collision algorithm
    state.players.forEach(playerA => {
        playerA.projectiles.forEach(projectile => {
            state.players.forEach(playerB => {
                if (playerA === playerB) {
                    // don't hit yourself
                    return
                }

                if (hitTestPlayerVsProjectile(playerB, projectile)) {
                    if (!(playerB.eliminated)) {
                    projectile.remove = true
                    }
                    if (playerB.playerId === myPlayerId) {
                        // others must remove themselves
                        playerB.eliminated = true
                        prompt("Du wurdest eliminiert.")
                    }
                }
            })
        })
    })

    // remove eliminated players
    // state.players = state.players.filter(player => !player.eliminated)

    socket.emit('stateUpdate', state.players[0])
}

function gameLoop () {
    requestAnimationFrame(gameLoop)
    logicStep(gameState)
    render(gameState)
}

gameLoop()


document.addEventListener('keydown', function (e) {
    keyboardState[e.key] = true

    if (e.key === ' ') { // spacebar lol

        const myPlayer = gameState.players[0]
        const projectile = {
            x: myPlayer.x, y: myPlayer.y,
            vx: 0, vy: 0
        }

        switch (myPlayer.rotation) {
            case FACING_DOWN: 
                projectile.vy = PROJECTILE_SPEED
                break
            case FACING_UP:
                projectile.vy = -PROJECTILE_SPEED
                break
            case FACING_LEFT:
                projectile.vx = -PROJECTILE_SPEED
                break
            case FACING_RIGHT:
                projectile.vx = +PROJECTILE_SPEED
                break
        }

        myPlayer.projectiles.push(projectile)
    }
})
document.addEventListener('keyup', function (e) {
    keyboardState[e.key] = false
})


socket.on('stateUpdateForwardedByServer', function (player) {
    if (player.playerId === myPlayerId) {
        // ignore own update
        return
    }

    let playerWasFound = false
    for (let i = 0; i < gameState.players.length; ++i) {
        if (gameState.players[i].playerId === player.playerId) {
            gameState.players[i] = player
            playerWasFound = true
            break // don't continue looping, pointless
        }
    }

    if (!playerWasFound) {
        // player we haven't seen before
        gameState.players.push(player)
    }
})
</script>

</body>
</html>
